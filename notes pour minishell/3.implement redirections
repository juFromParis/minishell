< should redirect input
> should redirect output
<< Here document : should be given a delimiter, then read the input until a line containing the delimiter is seen
It should not update the history
>> should redirect output in append mode
La syntaxe de la fonction open est la suivante :

int open(const char *pathname, int flags [, mode_t mode]);

    pathname : Chemin du fichier à ouvrir ou créer.
    flags : Drapeaux spécifiant le mode d'ouverture (lecture, écriture, etc.).
    mode : Permissions du fichier (optionnel, utilisé uniquement lors de la création).

Drapeaux courants

Les drapeaux les plus couramment utilisés incluent :

    O_RDONLY : Ouvre le fichier en lecture seule.
    O_WRONLY : Ouvre le fichier en écriture seule.
    O_RDWR : Ouvre le fichier en lecture et écriture.
    O_CREAT : Crée le fichier s'il n'existe pas.
    O_TRUNC : Truncature le fichier à zéro longueur s'il existe.
    O_APPEND : Ajoute les données à la fin du fichier.
    O_EXCL : Échoue si le fichier existe déjà (utilisé avec O_CREAT).


#include <stdio.h>

#include <unistd.h>
#include <fcntl.h>
#include <string.h>

int main() {
	int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd == -1) {
		perror("Erreur d'ouverture du fichier");
		return 1;
	}

	// Redirection de la sortie standard vers le fichier
	const char *message = "Ceci est un test de redirection de sortie.\n";
	write(fd, message, strlen(message));

	close(fd);
	return 0;
}

Gestion des erreurs

Pour gérer les erreurs de redirection, vérifiez toujours les pointeurs de fichiers :

if (file == NULL) {
    perror("Erreur de redirection");
    return 1;
}

Redirection avancée

Pour des redirections plus complexes, comme le <<, il est nécessaire de gérer les flux de manière plus sophistiquée. Voici un exemple de base :

#include <stdio.h>
#include <stdlib.h>

int main() {
	int fd = open("data.txt", O_RDONLY);
	if (fd == -1) {
		perror("Erreur d'ouverture du fichier");
		return 1;
	}

	// Lecture du contenu du fichier et exécution
	char buffer[1024];
	ssize_t bytes_read;
	char line[1024];
	int line_pos = 0;
	
	while ((bytes_read = read(fd, buffer, sizeof(buffer))) > 0) {
		for (int i = 0; i < bytes_read; i++) {
			if (buffer[i] == '\n') {
				line[line_pos] = '\0';
				// Exécuter chaque ligne comme une commande
				system(line);
				line_pos = 0;
			} else {
				line[line_pos++] = buffer[i];
				if (line_pos >= sizeof(line) - 1) {
					line[line_pos] = '\0';
					system(line);
					line_pos = 0;
				}
			}
		}
	}
	
	// Traiter la dernière ligne si elle ne se termine pas par '\n'
	if (line_pos > 0) {
		line[line_pos] = '\0';
		system(line);
	}

	close(fd);
	return 0;
}

